{"ast":null,"code":"import { supabase } from './supabaseClient';\nconst AZURE_ENDPOINT = process.env.REACT_APP_AZURE_TRANSLATOR_ENDPOINT;\nconst AZURE_KEY = process.env.REACT_APP_AZURE_TRANSLATOR_KEY;\nconst AZURE_REGION = process.env.REACT_APP_AZURE_REGION;\n\n// פונקציית השהייה\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// פורקציה לניקוי טקסט\nconst cleanText = text => {\n  return text.trim().replace(/\\r\\n/g, '\\n').replace(/\\n+/g, ' ').replace(/\\s+/g, ' ');\n};\n\n// פונקציה לחלוקת טקסט לחלקים קטנים\nconst splitIntoSmallChunks = (text, maxLength = 3000) => {\n  const cleanedText = cleanText(text);\n  if (cleanedText.length <= maxLength) {\n    return [cleanedText];\n  }\n  const chunks = [];\n  const sentences = cleanedText.split(/([.!?]+\\s)/);\n  let currentChunk = '';\n  for (let sentence of sentences) {\n    if ((currentChunk + sentence).length <= maxLength) {\n      currentChunk += sentence;\n    } else {\n      if (currentChunk) {\n        chunks.push(currentChunk.trim());\n      }\n      currentChunk = sentence;\n    }\n  }\n  if (currentChunk) {\n    chunks.push(currentChunk.trim());\n  }\n  return chunks;\n};\n\n// פונקציה לתרגום טקסט בודד\nconst translateSingleText = async (text, targetLang, retries = 3) => {\n  const chunks = splitIntoSmallChunks(text);\n  let translatedText = '';\n  for (const chunk of chunks) {\n    if (!chunk) continue;\n    for (let attempt = 0; attempt < retries; attempt++) {\n      try {\n        console.log(`מתרגם חלק באורך ${chunk.length} תווים`);\n        const response = await fetch(`${AZURE_ENDPOINT}/translate?api-version=3.0&to=${targetLang}`, {\n          method: 'POST',\n          headers: {\n            'Ocp-Apim-Subscription-Key': AZURE_KEY,\n            'Ocp-Apim-Subscription-Region': AZURE_REGION,\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify([{\n            text: chunk\n          }])\n        });\n        if (response.status === 429) {\n          console.log('התקבלה שגיאת Rate Limit, ממתין...');\n          const retryAfter = parseInt(response.headers.get('Retry-After') || '2');\n          await delay(retryAfter * 1000);\n          continue;\n        }\n        const responseText = await response.text();\n        if (!response.ok) {\n          throw new Error(`שגיאת שרת: ${response.status} - ${responseText}`);\n        }\n        const data = JSON.parse(responseText);\n        translatedText += ' ' + data[0].translations[0].text;\n\n        // המתנה קצרה בין חלקים\n        await delay(1000);\n        break;\n      } catch (error) {\n        console.error(`ניסיון ${attempt + 1} נכשל:`, error);\n        if (attempt === retries - 1) throw error;\n        await delay(2000 * (attempt + 1));\n      }\n    }\n  }\n  return translatedText.trim();\n};\n\n// פונקציה לפירוק קובץ SRT\nconst parseSRT = content => {\n  try {\n    const blocks = content.trim().split('\\n\\n');\n    return blocks.map((block, index) => {\n      const lines = block.split('\\n');\n      if (lines.length < 3) {\n        throw new Error(`בלוק לא תקין במיקום ${index + 1}`);\n      }\n      return {\n        index: index + 1,\n        timeCode: lines[1],\n        text: lines.slice(2).join('\\n')\n      };\n    });\n  } catch (error) {\n    console.error('שגיאה בפירוק הקובץ:', error);\n    throw new Error(`שגיאה בפירוק הקובץ: ${error.message}`);\n  }\n};\nexport const translateSRT = async (content, targetLang, onProgress) => {\n  try {\n    console.log('מתחיל תרגום...'); // לוג לבדיקה\n    const blocks = parseSRT(content);\n    console.log(`נמצאו ${blocks.length} בלוקים`); // לוג לבדיקה\n\n    const translatedBlocks = [];\n    let lastProgress = 0;\n    for (let i = 0; i < blocks.length; i++) {\n      const block = blocks[i];\n      try {\n        console.log(`מתרגם בלוק ${i + 1}/${blocks.length}`); // לוג לבדיקה\n        const translatedText = await translateSingleText(block.text, targetLang);\n        translatedBlocks.push({\n          ...block,\n          text: translatedText\n        });\n        const progress = Math.round((i + 1) / blocks.length * 100);\n        if (progress > lastProgress) {\n          lastProgress = progress;\n          if (onProgress) {\n            onProgress(progress);\n          }\n        }\n      } catch (error) {\n        console.error(`שגיאה בתרגום בלוק ${i + 1}:`, error);\n        throw new Error(`שגיאה בתרגום בלוק ${i + 1}: ${error.message}`);\n      }\n    }\n    const result = translatedBlocks.map(block => `${block.index}\\n${block.timeCode}\\n${block.text}`).join('\\n\\n');\n    console.log('התרגום הושלם בהצלחה'); // לוג לבדיקה\n    return result;\n  } catch (error) {\n    console.error('שגיאה בתרגום הקובץ:', error);\n    throw error;\n  }\n};\nexport const uploadFile = async file => {\n  try {\n    const fileName = `${Date.now()}-${file.name}`;\n    const {\n      data: storageData,\n      error: storageError\n    } = await supabase.storage.from('srt-files').upload(fileName, file);\n    if (storageError) throw storageError;\n    const {\n      data: fileData,\n      error: dbError\n    } = await supabase.from('files').insert([{\n      name: file.name,\n      storage_path: storageData.path,\n      size: file.size,\n      created_at: new Date()\n    }]).select();\n    if (dbError) throw dbError;\n    return fileData[0];\n  } catch (error) {\n    console.error('שגיאה בהעלאת הקובץ:', error.message);\n    throw error;\n  }\n};\nexport const getFiles = async () => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('files').select('*').order('created_at', {\n      ascending: false\n    });\n    if (error) throw error;\n    return data;\n  } catch (error) {\n    console.error('שגיאה בקבלת הקבצים:', error.message);\n    throw error;\n  }\n};","map":{"version":3,"names":["supabase","AZURE_ENDPOINT","process","env","REACT_APP_AZURE_TRANSLATOR_ENDPOINT","AZURE_KEY","REACT_APP_AZURE_TRANSLATOR_KEY","AZURE_REGION","REACT_APP_AZURE_REGION","delay","ms","Promise","resolve","setTimeout","cleanText","text","trim","replace","splitIntoSmallChunks","maxLength","cleanedText","length","chunks","sentences","split","currentChunk","sentence","push","translateSingleText","targetLang","retries","translatedText","chunk","attempt","console","log","response","fetch","method","headers","body","JSON","stringify","status","retryAfter","parseInt","get","responseText","ok","Error","data","parse","translations","error","parseSRT","content","blocks","map","block","index","lines","timeCode","slice","join","message","translateSRT","onProgress","translatedBlocks","lastProgress","i","progress","Math","round","result","uploadFile","file","fileName","Date","now","name","storageData","storageError","storage","from","upload","fileData","dbError","insert","storage_path","path","size","created_at","select","getFiles","order","ascending"],"sources":["C:/Users/Liran/.cursor-tutor/SRT-Translator/src/client/index.js"],"sourcesContent":["import { supabase } from './supabaseClient'\r\n\r\nconst AZURE_ENDPOINT = process.env.REACT_APP_AZURE_TRANSLATOR_ENDPOINT\r\nconst AZURE_KEY = process.env.REACT_APP_AZURE_TRANSLATOR_KEY\r\nconst AZURE_REGION = process.env.REACT_APP_AZURE_REGION\r\n\r\n// פונקציית השהייה\r\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\n// פורקציה לניקוי טקסט\r\nconst cleanText = (text) => {\r\n  return text\r\n    .trim()\r\n    .replace(/\\r\\n/g, '\\n')\r\n    .replace(/\\n+/g, ' ')\r\n    .replace(/\\s+/g, ' ');\r\n};\r\n\r\n// פונקציה לחלוקת טקסט לחלקים קטנים\r\nconst splitIntoSmallChunks = (text, maxLength = 3000) => {\r\n  const cleanedText = cleanText(text);\r\n  if (cleanedText.length <= maxLength) {\r\n    return [cleanedText];\r\n  }\r\n\r\n  const chunks = [];\r\n  const sentences = cleanedText.split(/([.!?]+\\s)/);\r\n  let currentChunk = '';\r\n\r\n  for (let sentence of sentences) {\r\n    if ((currentChunk + sentence).length <= maxLength) {\r\n      currentChunk += sentence;\r\n    } else {\r\n      if (currentChunk) {\r\n        chunks.push(currentChunk.trim());\r\n      }\r\n      currentChunk = sentence;\r\n    }\r\n  }\r\n\r\n  if (currentChunk) {\r\n    chunks.push(currentChunk.trim());\r\n  }\r\n\r\n  return chunks;\r\n};\r\n\r\n// פונקציה לתרגום טקסט בודד\r\nconst translateSingleText = async (text, targetLang, retries = 3) => {\r\n  const chunks = splitIntoSmallChunks(text);\r\n  let translatedText = '';\r\n\r\n  for (const chunk of chunks) {\r\n    if (!chunk) continue;\r\n\r\n    for (let attempt = 0; attempt < retries; attempt++) {\r\n      try {\r\n        console.log(`מתרגם חלק באורך ${chunk.length} תווים`);\r\n\r\n        const response = await fetch(`${AZURE_ENDPOINT}/translate?api-version=3.0&to=${targetLang}`, {\r\n          method: 'POST',\r\n          headers: {\r\n            'Ocp-Apim-Subscription-Key': AZURE_KEY,\r\n            'Ocp-Apim-Subscription-Region': AZURE_REGION,\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify([{ text: chunk }])\r\n        });\r\n\r\n        if (response.status === 429) {\r\n          console.log('התקבלה שגיאת Rate Limit, ממתין...');\r\n          const retryAfter = parseInt(response.headers.get('Retry-After') || '2');\r\n          await delay(retryAfter * 1000);\r\n          continue;\r\n        }\r\n\r\n        const responseText = await response.text();\r\n        \r\n        if (!response.ok) {\r\n          throw new Error(`שגיאת שרת: ${response.status} - ${responseText}`);\r\n        }\r\n\r\n        const data = JSON.parse(responseText);\r\n        translatedText += ' ' + data[0].translations[0].text;\r\n        \r\n        // המתנה קצרה בין חלקים\r\n        await delay(1000);\r\n        break;\r\n      } catch (error) {\r\n        console.error(`ניסיון ${attempt + 1} נכשל:`, error);\r\n        if (attempt === retries - 1) throw error;\r\n        await delay(2000 * (attempt + 1));\r\n      }\r\n    }\r\n  }\r\n\r\n  return translatedText.trim();\r\n};\r\n\r\n// פונקציה לפירוק קובץ SRT\r\nconst parseSRT = (content) => {\r\n  try {\r\n    const blocks = content.trim().split('\\n\\n');\r\n    return blocks.map((block, index) => {\r\n      const lines = block.split('\\n');\r\n      if (lines.length < 3) {\r\n        throw new Error(`בלוק לא תקין במיקום ${index + 1}`);\r\n      }\r\n      return {\r\n        index: index + 1,\r\n        timeCode: lines[1],\r\n        text: lines.slice(2).join('\\n')\r\n      };\r\n    });\r\n  } catch (error) {\r\n    console.error('שגיאה בפירוק הקובץ:', error);\r\n    throw new Error(`שגיאה בפירוק הקובץ: ${error.message}`);\r\n  }\r\n};\r\n\r\nexport const translateSRT = async (content, targetLang, onProgress) => {\r\n  try {\r\n    console.log('מתחיל תרגום...'); // לוג לבדיקה\r\n    const blocks = parseSRT(content);\r\n    console.log(`נמצאו ${blocks.length} בלוקים`); // לוג לבדיקה\r\n    \r\n    const translatedBlocks = [];\r\n    let lastProgress = 0;\r\n\r\n    for (let i = 0; i < blocks.length; i++) {\r\n      const block = blocks[i];\r\n      try {\r\n        console.log(`מתרגם בלוק ${i + 1}/${blocks.length}`); // לוג לבדיקה\r\n        const translatedText = await translateSingleText(block.text, targetLang);\r\n        translatedBlocks.push({\r\n          ...block,\r\n          text: translatedText\r\n        });\r\n\r\n        const progress = Math.round(((i + 1) / blocks.length) * 100);\r\n        if (progress > lastProgress) {\r\n          lastProgress = progress;\r\n          if (onProgress) {\r\n            onProgress(progress);\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`שגיאה בתרגום בלוק ${i + 1}:`, error);\r\n        throw new Error(`שגיאה בתרגום בלוק ${i + 1}: ${error.message}`);\r\n      }\r\n    }\r\n\r\n    const result = translatedBlocks\r\n      .map(block => `${block.index}\\n${block.timeCode}\\n${block.text}`)\r\n      .join('\\n\\n');\r\n    \r\n    console.log('התרגום הושלם בהצלחה'); // לוג לבדיקה\r\n    return result;\r\n  } catch (error) {\r\n    console.error('שגיאה בתרגום הקובץ:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nexport const uploadFile = async (file) => {\r\n  try {\r\n    const fileName = `${Date.now()}-${file.name}`\r\n    const { data: storageData, error: storageError } = await supabase.storage\r\n      .from('srt-files')\r\n      .upload(fileName, file)\r\n    \r\n    if (storageError) throw storageError\r\n\r\n    const { data: fileData, error: dbError } = await supabase\r\n      .from('files')\r\n      .insert([\r\n        { \r\n          name: file.name,\r\n          storage_path: storageData.path,\r\n          size: file.size,\r\n          created_at: new Date()\r\n        }\r\n      ])\r\n      .select()\r\n    \r\n    if (dbError) throw dbError\r\n    return fileData[0]\r\n  } catch (error) {\r\n    console.error('שגיאה בהעלאת הקובץ:', error.message)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport const getFiles = async () => {\r\n  try {\r\n    const { data, error } = await supabase\r\n      .from('files')\r\n      .select('*')\r\n      .order('created_at', { ascending: false })\r\n    \r\n    if (error) throw error\r\n    return data\r\n  } catch (error) {\r\n    console.error('שגיאה בקבלת הקבצים:', error.message)\r\n    throw error\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}